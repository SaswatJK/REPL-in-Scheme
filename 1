;;Try writing iteratively.

(define (expr num)
  (if (number? num)
    num
  ("Not a number")))

(define-syntax swap
  (syntax-rules ()
    ((swap exprA exprB)
     (let ((tmp exprA))
       (set! exprA exprB)
       (set! exprB tmp)))))

;; The code at first is just me following the schem org docs' minimal interpreter.

;; LISP stores stuff as symbols, which have a print name, "The string of characters that represent it to the programmer", the value cell : the value of that symbol, the function cell : The function definition of the symbol, property list: Assosciated properties to that symbol, and package : Namespace assosciated to that symbol.

;; We can convert a string to a symbol and literally call that symbol (if callable) easily.

;;(define (nameOfVar) 4)
;;(define getVar "nameOfVar") ;;Let's say we define a variable which has it's value to be the name of a supposed symbol.
;;(display (nameOfVar)) ;;Prints 4.
;;(display getVar) ;;Prints "nameOfVar".
;;(display ((eval (string->symbol getVar) (interaction-environment)))) ;;Prints 4 again.

;; Note that it refers to a symbol and not just a procedure, nameOfvar could may as well have been a normal variable.

(define (read-word currentChar)
  (define (read-word-helper word-so-far) ;word-so-far acts as an accumulator.
    (let ((next-character (peek-char)))
      (if (or (char-alphabetic? next-character)
              (char-numeric? next-character))
        (read-word-helper (cons (read-char) word-so-far)) ;Recursive.
        (reverse word-so-far))))
  (string->symbol ;We just create a symbol out of the string, if already a symbol, we get the symbol's pointer itself. As with all things LISP.
  (list->string ;Creates a scheme string object with the given sequence of characters.
  (read-word-helper (list currentChar))))) ;Read ^ downside up. Returns the accumulated list of characters.

(define (read-num currentNum)
  (define (read-num-helper num-so-far)
    (let ((next-digit (peek-char)))
      (if (char-numeric? next-digit)
        (read-num-helper (cons next-digit num-so-far)))
        (reverse num-so-far)))
  (string->number ;We just create a number out of the string.
    (list->string (read-num-helper (list currentNum)))))

(define left-paren-token
  (list '*left-paranthesis*)) ;;Quote stops eval, treats it as a literal.

(define right-paren-token
  (list '*right-parenthesis*))

(define (ReadChar)
  (let ((currentChar (read-char))) ;intrinsic proc
    (cond ((char-whitespace? currentChar)
           (ReadChar))
           ((eq? currentChar #\( )
           left-paren-token)
           ((eq? currentChar #\) )
            right-paren-token)
           ((char-alphabetic? currentChar)
            (read-word currentChar))
           ((char-numeric? currentChar)
            (read-number currentChar))
           (else
             (error "Cannot handle this character token")))))

(define (leftParen? ch)
  (eq? ch left-paren-token))

(define (rightParen? ch)
  (eq? ch right-paren-token))

(define (simpleRead)
  (let ((nextToken (ReadChar))
    (cond ((leftParen? nextToken)
           (read-list '()))
          (else
            nextToken))))

(define (REPL)
  (display "rEPL| ")
  (let ((expr (read)))
    (cond ((eq? expr 'halt)  ;eq checks if it referes to the same object, rather than checking the list itself.
           (newline)
           (display "Exiting the repl"))
          (#t
          (write (eval (expr))
          (newline)
          (REPL)) ;Tail recursion.
          ))))


(display "Hello world")
(newline)
(display (expr 5))
(newline)
;(REPL)
(ReadChar)
(newline)
(newline)
(newline)
